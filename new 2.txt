import os
import re
import io
import pandas as pd
from openpyxl import load_workbook
import fitz  # PyMuPDF

# --- CONFIG ---
PDF_FOLDER = r"D:\Path\To\Your\PDFs"         # <-- change this
OUTPUT_XLSX = "activity_summary_results.xlsx"
# If you want CSV instead, set OUTPUT_CSV = "activity_summary_results.csv" and save df.to_csv(...)

# Headings we will look for inside the PDF
HEADING_PATTERNS = [
    r"\bsummary\s+of\s+activity\b",
    r"\bactivity\s+summary\b",
    r"\bsummary\s*[-:]\s*activity\b",
]
HEADING_RE = re.compile("|".join(HEADING_PATTERNS), flags=re.IGNORECASE)

def extract_embedded_excel_bytes(pdf_path):
    """
    Return bytes of first embedded Excel named like UTR*.xlsx if present; else None.
    Works for email-like PDFs with actual attachments embedded.
    """
    with fitz.open(pdf_path) as doc:
        # Newer PyMuPDF
        try:
            for att in doc.attachments():
                name = att.get("filename", "")
                if name and name.lower().endswith(".xlsx") and name.lower().startswith("utr"):
                    return att["filedata"]
        except Exception:
            pass

        # Older API fallback
        try:
            for name in doc.embeddedFileNames():
                if name.lower().endswith(".xlsx") and name.lower().startswith("utr"):
                    ef = doc.embeddedFileGet(name)
                    return ef.tobytes()
        except Exception:
            pass
    return None

def read_summary_from_excel_bytes(excel_bytes):
    """
    Open an in-memory .xlsx and read merged text across C39:I41.
    """
    try:
        wb = load_workbook(io.BytesIO(excel_bytes), data_only=True)
        ws = wb.active
        vals = []
        for row in ws.iter_rows(min_row=39, max_row=41, min_col=3, max_col=9):
            for cell in row:
                if cell.value not in (None, ""):
                    vals.append(str(cell.value))
        return " ".join(vals).strip()
    except Exception as e:
        return f"Error reading Excel: {e}"

def clean_text(t: str) -> str:
    if not t:
        return ""
    t = t.replace("\r", " ").replace("\n", " ")
    t = re.sub(r"\s+", " ", t)
    return t.strip(" :-\t")

def extract_summary_from_pdf_text(pdf_path):
    """
    Use PyMuPDF's block layout:
    - search for a heading (Summary of Activity / Activity Summary / etc.)
    - if found: return text after the label (same block) or the next non-empty block
    """
    with fitz.open(pdf_path) as doc:
        for page in doc:
            # each block = (x0, y0, x1, y1, "text", block_no, block_type, ...)
            blocks = page.get_text("blocks")
            # sort by reading order (y, then x)
            blocks.sort(key=lambda b: (round(b[1], 1), round(b[0], 1)))

            for i, b in enumerate(blocks):
                text = b[4] if len(b) > 4 else ""
                if not text:
                    continue
                raw = text
                text_norm = clean_text(raw)

                # If heading appears in this block
                if HEADING_RE.search(text_norm):
                    # 1) Try to capture text after the heading inside this same block
                    # e.g., "Summary of Activity: Account Closeout."
                    after_same_block = re.split(HEADING_RE, text_norm, maxsplit=1, flags=re.IGNORECASE)[-1]
                    after_same_block = after_same_block.strip(" :-")
                    if after_same_block:
                        return after_same_block

                    # 2) Else use the next non-empty block
                    for j in range(i + 1, min(i + 6, len(blocks))):  # look ahead a few blocks
                        nxt = clean_text(blocks[j][4] if len(blocks[j]) > 4 else "")
                        if nxt:
                            return nxt

        # Fallback: sometimes there is no explicit heading; try to find short, strong phrase lines
        # (e.g., "Account Closeout.")
        # Heuristic: take the first short sentence made of 2–6 words, ending with a period.
        for page in doc:
            txt = page.get_text("text") or ""
            lines = [clean_text(x) for x in txt.splitlines()]
            for line in lines:
                if 10 <= len(line) <= 80 and line.endswith("."):
                    words = len(line.split())
                    if 2 <= words <= 10:
                        return line

    return None

def process_pdf(pdf_path):
    # 1) If an embedded UTR .xlsx exists, prefer that (email-like PDFs)
    excel_bytes = extract_embedded_excel_bytes(pdf_path)
    if excel_bytes:
        summary = read_summary_from_excel_bytes(excel_bytes)
        if summary and not summary.lower().startswith("error"):
            return summary

    # 2) Otherwise parse the PDF text layout itself (Excel-generated PDFs are text-based)
    summary = extract_summary_from_pdf_text(pdf_path)
    if summary:
        return summary

    return "Not found"

def main():
    results = []
    for name in os.listdir(PDF_FOLDER):
        if not name.lower().endswith(".pdf"):
            continue
        pdf_path = os.path.join(PDF_FOLDER, name)
        try:
            print(f"Processing: {name}")
            summary = process_pdf(pdf_path)
        except Exception as e:
            summary = f"Error: {e}"
        results.append({"PDF_File_Name": name, "Activity_Summary": summary})

    df = pd.DataFrame(results)
    df.to_excel(OUTPUT_XLSX, index=False)
    # If you prefer CSV: df.to_csv("activity_summary_results.csv", index=False)
    print(f"\n✅ Done. Saved to {OUTPUT_XLSX}")

if __name__ == "__main__":
    main()
